◆１.寿命管理されるタスクの順次更新処理を行いたい
・理由(使用するデータ構造 : リスト
頻繫に生成、削除されることが考えられるため、
どの位置に対する挿入削除でも高速な動作が期待できるリストが適切と考えました。


◆２.連番のIDをキーとして要素を取得したい
・理由(使用するデータ構造 : 配列
ID(キー)からデータを高速に取得する、またそのIDが既知の範囲の連番であることから
順に要素を参照できる配列が適切と考えました。


◆３.ランダムなIDをキーとして要素を取得したい
・理由(使用するデータ構造 : ハッシュテーブル
ID(キー)からデータを高速に取得する、またそのIDがランダムな値ということから
ハッシュから要素を参照できるハッシュテーブルが適切と考えました。


◆４.派生クラスを順次実行したい
・理由(使用するデータ構造 : キュー
登録順(先に来たものから)に順次実行することと、一度きりの実行ということで、
FIFOの特性を持つキューが適切と考えました。


◆５.バイナリ内に格納された数式の解析機を作成した
・理由(使用するデータ構造 : スタック
逆ポーランド記法でデータが格納されることから、
式を前から順に積み、演算子が来たら引数を取り出してその結果をまた積みこむ、
逆ポーランド記法の解析処理に用いるのにも都合がいいスタックが適切と考えました。